/** 
	SAMPLE SERVICE WORKER !! 
	   -- This content is an alternative created by the plugin "Astrojs-sw"
	
	Create a directory to contain your Service Worker files at path: "./src/sw/".
	
	The Astrojs-sw plugin will load and parse the contents of files contained in this 
		  directory to "./public/sw.js" during development mode and to the path "./dist/sw.js" in build.
	
	Some parameters can be configured in your application's "astro.config":
	
	---- astro.config.mjs ----
	```
		  import { defineConfig } from 'astro/config';
		  import sw from 'astrojs-sw'
	
		  const sw_config = {
				dir: './src/sw', 				// path of files to be concatenated (default: './src/sw')
				order: [						// optional concatenation ordering (files with ".js" extension only)
				'cache', 
				'push/click.js',
				'fetch',
				// etc... 
			],	
				filename: 'sw.js', 				// final filename (default: 'sw.js')
				auto: true, 					// generate cache version automatically (default: true)
				obfuscate: false, 				// build only: add obfuscation (default false)
				uglify: false, 					// build only: add uglify (default false)
		  }
	
		  export default defineConfig({
				integrations: [
					// ...
			
					sw(sw_config), 				// or just sw(), if you want to use the defaults
			
					// ...
				]
		  });
	```
	
	---- ASSETS ----
	
	An ASSETS constant is added by Astrojs-sw to list the files to be cached in the 
			client's browser. In "dev" mode this array will be empty.
	
	If you need to add files to the list, use "push" on this array:
	
	```ASSETS.push( 'file' );```
	
	Any file accessible by the browser in "dev" mode can be added. Your service 
			worker must use ASSETS to populate the browser's cache.
	
	In "production" mode, after the build, ASSETS will be AUTOMATICALLY populated 
			with the files generated by Astro Builder in the "./dist" folder.
	
*/

// INSTALL  -------------------------------------------------------------------
self.addEventListener('install', e =>
	e.waitUntil(
		caches.open(CACHE).then((cache) => {
			console.log(`[SWORKER install] caching "${CACHE}"`)
			cache.addAll(ASSETS)
		}).then(() => {
			sendMessage({ text: 'install' })
			self.skipWaiting()
		})
	)
)

// ACTIVATE -------------------------------------------------------------------
self.addEventListener('activate', e =>
	e.waitUntil(
		caches.keys().then(async (ks) => {
			for (const k of ks) {
				if (k !== CACHE) {
					console.log(`[SWORKER removing] cache "${k}"`)
					await caches.delete(k)
				}
			}
			sendMessage({ text: 'activate', action: 'reset' })
			self.clients.claim()
		})
	)
)

// FETCH ----------------------------------------------------------------------
const CONFIG = '/config'
self.addEventListener('fetch', (event) => {
	const {
		request,
		request: { url, method }
	} = event

	// Save||load json data in Cache Storage CONFIG file
	if (url.match(CONFIG)) {
		if (method === 'POST') {
			request
				.json()
				.then((body) =>
					caches
						.open(CACHE)
						.then((cache) =>
							cache.put(
								CONFIG,
								new Response(JSON.stringify(body)),
							)
						)
				)
			return event.respondWith(new Response('{}'))
		} else {
			return event.respondWith(
				caches
					.match(CONFIG)
					.then((response) => response || new Response('{}'))
			)
		}
	} else {
		// Get & save request in Cache Storage
		if (method !== 'POST') {
			event.respondWith(
				caches.open(CACHE).then(async (cache) => {

					let response = await cache.match(event.request)
					if (response) return response

					// To fix 'chrome-extension'
					if (url.startsWith('chrome-extension') ||
						url.includes('extension') ||
						!(url.indexOf('http') === 0))
						return await fetch(event.request)

					response = await cache.match(event.request.url += 'index.html')
					if (response) return response

					response = await cache.match(event.request.url += '/index.html')
					if (response) return response

					response = await fetch(event.request)

					// To save the request in the cache.
					// ğŸ‘‡ It can cause problems if not carefully filtered.
					if (url.startsWith('https://i.ytimg.com') ||
						url.startsWith('https://fonts.g')) cache.put(event.request, response.clone())

					return response
				})
			)
		}
	}
})

// MESSAGE --------------------------------------------------------------------
// Receive messages from the main script.
self.onmessage = function (e) {
	if (e.data.action === 'skipWaiting') {
		self.skipWaiting()
	}
	if (e.data.action === 'update') {
		self.registration.update()
	}
	if (e.data.action === 'sync') {
		self.registration.sync.register('sync-news')
			.then(() => {
				// ...
			})
	}
	sendMessage({ type: 'receive', msg: e.data })
}

// Send a message to the main script.
function sendMessage(message) {
	self.clients.matchAll().then(a => {
		if (a[0]) {
			self.clients.get(a[0].id).then(client => {
				client.postMessage(message)
			})
		}
	})
}